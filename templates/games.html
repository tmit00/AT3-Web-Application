{% extends "base.html" %}

{% block title %}FocusFlow - Break Games{% endblock %}

{% block content %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/pomodoro.css') }}">

<div class="pomodoro-container">
    <h1>Break Games</h1>
    <div id="break-timer-display" class="break-timer-info" style="display:none;">
        <span id="break-time-left">Break time: 5:00</span>
    </div>   
    <div class="snake-game-outer">
        <!-- Simple Snake Game -->
        <div class="snake-game-container">
            <div id="highscore" class="snake-highscore">
                High Score: 0
            </div>
            <div class="snake-canvas-wrapper">
                <canvas id="snakeGame" width="340" height="400"></canvas>
                <div id="countdownOverlay" class="snake-countdown-overlay"></div>
            </div>
            <button id="restartBtn" class="snake-restart-btn">Restart Game</button>
        </div>
    </div>
    
    <div class="back-to-pomodoro">
        <a href="{{ url_for('todo_routes.pomodoro') }}">
            <span>‚Üê</span>
            Back to Timer
        </a>
    </div>
</div>

<script>
// Simple Snake Game in JavaScript with Restart, High Score, Countdown, and Safe Food Spawn
const canvas = document.getElementById('snakeGame');
const ctx = canvas.getContext('2d');
const box = 20;
let snake, direction, nextDirection, food, score, game, gameOver;
let highScore = localStorage.getItem('snakeHighScore') ? parseInt(localStorage.getItem('snakeHighScore')) : 0;
const highscoreDiv = document.getElementById('highscore');
const countdownOverlay = document.getElementById('countdownOverlay');
let countdownTimeout, countdownValue;

// Break timer monitoring
let breakTimerMonitor = null;
let gameAccessAllowed = false;
let breakTimeExpired = false;
let lastKnownMode = null;
const breakTimerDisplay = document.getElementById('break-timer-display');
const breakTimeLeft = document.getElementById('break-time-left');

function updateHighScoreDisplay() {
    highscoreDiv.textContent = "High Score: " + highScore;
}

// Check if game access is allowed based on timer state
function checkGameAccess() {
    const stateStr = localStorage.getItem('pomodoroTimerState');
    if (!stateStr) {
        gameAccessAllowed = false;
        return false;
    }
    
    try {
        const state = JSON.parse(stateStr);
        let timeLeft = state.timeLeft || 0;
        
        // Calculate actual time left if timer is running
        if (state.running && !state.paused && state.timestamp) {
            const elapsed = Math.floor((Date.now() - state.timestamp) / 1000);
            timeLeft = Math.max(0, timeLeft - elapsed);
        }
        
        // Allow access only during break modes with time remaining
        const isBreakMode = (state.mode === "shortBreak" || state.mode === "longBreak");
        const wasBreakMode = gameAccessAllowed; // Track previous state
        gameAccessAllowed = isBreakMode && timeLeft > 0;
        
        // If we were in break mode but now we're not, break has expired
        if (wasBreakMode && !gameAccessAllowed) {
            breakTimeExpired = true;
        }
        
        return gameAccessAllowed;
    } catch (e) {
        console.warn('Failed to parse timer state:', e);
        gameAccessAllowed = false;
        return false;
    }
}

// Handle break timer expiration
function handleBreakExpiration() {
    if (game) clearInterval(game);
    gameOver = true;
    breakTimeExpired = true;
    
    // Show break expired message
    ctx.fillStyle = "#1a202c";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#fff";
    ctx.font = "24px Inter, Arial, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Break Time Over!", canvas.width/2, canvas.height/2 - 20);
    ctx.font = "16px Inter, Arial, sans-serif";
    ctx.fillText("Returning to work...", canvas.width/2, canvas.height/2 + 10);
    
    // Redirect to pomodoro page after a short delay
    setTimeout(() => {
        window.location.href = "{{ url_for('todo_routes.pomodoro') }}";
    }, 2000);
}

// Show access denied message
function showAccessDenied() {
    ctx.fillStyle = "#1a202c";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#f56565";
    ctx.font = "20px Inter, Arial, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Games Locked!", canvas.width/2, canvas.height/2 - 30);
    ctx.fillStyle = "#fff";
    ctx.font = "14px Inter, Arial, sans-serif";
    ctx.fillText("Start a Pomodoro break", canvas.width/2, canvas.height/2);
    ctx.fillText("to unlock games", canvas.width/2, canvas.height/2 + 20);
}

// Update break timer display
function updateBreakTimerDisplay() {
    const stateStr = localStorage.getItem('pomodoroTimerState');
    if (!stateStr || !breakTimerDisplay || !breakTimeLeft) return;
    
    try {
        const state = JSON.parse(stateStr);
        let timeLeft = state.timeLeft || 0;
        
        // Calculate actual time left if timer is running
        if (state.running && !state.paused && state.timestamp) {
            const elapsed = Math.floor((Date.now() - state.timestamp) / 1000);
            timeLeft = Math.max(0, timeLeft - elapsed);
        }
        
        if (timeLeft > 0 && (state.mode === "shortBreak" || state.mode === "longBreak")) {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            const timeStr = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            const modeText = state.mode === "shortBreak" ? "Break" : "Long Break";
            
            breakTimeLeft.textContent = `${modeText} time: ${timeStr}`;
            breakTimerDisplay.style.display = 'block';
        } else {
            breakTimerDisplay.style.display = 'none';
        }
    } catch (e) {
        breakTimerDisplay.style.display = 'none';
    }
}

// Monitor break timer continuously
function startBreakTimerMonitoring() {
    if (breakTimerMonitor) clearInterval(breakTimerMonitor);
    
    breakTimerMonitor = setInterval(() => {
        const stateStr = localStorage.getItem('pomodoroTimerState');
        if (stateStr) {
            try {
                const state = JSON.parse(stateStr);
                const currentMode = state.mode;
                
                // Detect mode transition from break to work
                if (lastKnownMode && 
                    (lastKnownMode === "shortBreak" || lastKnownMode === "longBreak") && 
                    currentMode === "work") {
                    console.log('Detected break-to-work transition');
                    if (!breakTimeExpired) {
                        handleBreakExpiration();
                    }
                    return;
                }
                
                lastKnownMode = currentMode;
            } catch (e) {
                console.warn('Failed to parse timer state for monitoring:', e);
            }
        }
        
        updateBreakTimerDisplay();
        if (!checkGameAccess()) {
            if (!breakTimeExpired) {
                handleBreakExpiration();
            }
        }
    }, 500); // Check every half second for more responsive detection
}

function getRandomFoodPosition() {
    let newFood;
    let collision;
    do {
        newFood = {
            x: Math.floor(Math.random()*((canvas.width/box)-1)) * box,
            y: Math.floor(Math.random()*((canvas.height/box)-1)) * box
        };
        collision = snake.some(segment => segment.x === newFood.x && segment.y === newFood.y);
    } while (collision);
    return newFood;
}

function drawSnake() {
    snake.forEach((segment, index) => {
        if (index === 0) {
            // Head
            ctx.fillStyle = "#667eea";
            ctx.fillRect(segment.x, segment.y, box, box);
            ctx.strokeStyle = "#4a5568";
            ctx.lineWidth = 2;
            ctx.strokeRect(segment.x, segment.y, box, box);
        } else {
            // Body
            ctx.fillStyle = "#48bb78";
            ctx.fillRect(segment.x, segment.y, box, box);
            ctx.strokeStyle = "#38a169";
            ctx.lineWidth = 1;
            ctx.strokeRect(segment.x, segment.y, box, box);
        }
    });
}

function drawFood() {
    ctx.fillStyle = "#f56565";
    ctx.fillRect(food.x, food.y, box, box);
    ctx.strokeStyle = "#e53e3e";
    ctx.lineWidth = 2;
    ctx.strokeRect(food.x, food.y, box, box);
}

function drawScore() {
    ctx.fillStyle = "#fff";
    ctx.font = "20px Inter, Arial, sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Score: " + score, 10, 30);
}

function drawGameOver() {
    ctx.fillStyle = "rgba(26, 32, 44, 0.9)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = "#fff";
    ctx.font = "32px Inter, Arial, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Game Over!", canvas.width/2, canvas.height/2 - 40);
    
    ctx.font = "18px Inter, Arial, sans-serif";
    ctx.fillText("Final Score: " + score, canvas.width/2, canvas.height/2);
    
    if (score > highScore) {
        ctx.fillStyle = "#48bb78";
        ctx.font = "16px Inter, Arial, sans-serif";
        ctx.fillText("New High Score!", canvas.width/2, canvas.height/2 + 30);
    }
    
    ctx.fillStyle = "#fff";
    ctx.font = "14px Inter, Arial, sans-serif";
    ctx.fillText("Press Restart to play again", canvas.width/2, canvas.height/2 + 60);
}

function gameLoop() {
    if (gameOver) return;
    
    // Update direction
    direction = nextDirection;
    
    // Move snake
    const head = {x: snake[0].x, y: snake[0].y};
    
    switch(direction) {
        case "UP": head.y -= box; break;
        case "DOWN": head.y += box; break;
        case "LEFT": head.x -= box; break;
        case "RIGHT": head.x += box; break;
    }
    
    // Check collision with walls
    if (head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height) {
        gameOver = true;
        return;
    }
    
    // Check collision with self
    if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
        gameOver = true;
        return;
    }
    
    snake.unshift(head);
    
    // Check if food is eaten
    if (head.x === food.x && head.y === food.y) {
        score += 10;
        food = getRandomFoodPosition();
        
        // Update high score
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('snakeHighScore', highScore);
            updateHighScoreDisplay();
        }
    } else {
        snake.pop();
    }
    
    // Clear canvas
    ctx.fillStyle = "#1a202c";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw game elements
    drawSnake();
    drawFood();
    drawScore();
}

function startGame() {
    // Initialize game state
    snake = [{x: 160, y: 200}, {x: 140, y: 200}, {x: 120, y: 200}];
    direction = "RIGHT";
    nextDirection = "RIGHT";
    food = getRandomFoodPosition();
    score = 0;
    gameOver = false;
    
    // Clear any existing game loop
    if (game) clearInterval(game);
    
    // Start game loop
    game = setInterval(gameLoop, 100);
}

function restartGame() {
    if (game) clearInterval(game);
    startGame();
}

// Event listeners
document.addEventListener('keydown', function(e) {
    if (gameOver) return;
    
    switch(e.key) {
        case "ArrowUp":
            if (direction !== "DOWN") nextDirection = "UP";
            break;
        case "ArrowDown":
            if (direction !== "UP") nextDirection = "DOWN";
            break;
        case "ArrowLeft":
            if (direction !== "RIGHT") nextDirection = "LEFT";
            break;
        case "ArrowRight":
            if (direction !== "LEFT") nextDirection = "RIGHT";
            break;
    }
});

document.getElementById('restartBtn').addEventListener('click', restartGame);

// Initialize game
document.addEventListener('DOMContentLoaded', function() {
    updateHighScoreDisplay();
    
    // Check initial access
    if (!checkGameAccess()) {
        showAccessDenied();
    } else {
        startGame();
    }
    
    // Start monitoring
    startBreakTimerMonitoring();
    
    // Update timer display
    updateBreakTimerDisplay();
});
</script>
{% endblock %}
